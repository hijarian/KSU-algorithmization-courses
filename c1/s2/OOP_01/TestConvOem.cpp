//—————————————————————————————————————————————————————————————————————————————
// Модуль:
//	TestConvOem.cpp
// Назначение:
//	Пример программы тестирования класса преобразования (конверсии) символов и
//	символьных массивов (C-строк) Windows в кодировку OEM и обратно (CConvOem).
// Пояснения:
//	Поддерживаются только мультибайтовые строки (стандарт ANSI).
//—————————————————————————————————————————————————————————————————————————————
// Автор:
//	© Романовский Э.А., Российская Федерация, р. Татарстан,
//	г. Набережные Челны, КамПИ, каф. АиИТ, 20.02.2004.
// Переработано:
//	© Романовский Э.А., Российская Федерация, р. Татарстан,
//	г. Набережные Челны, КамПИ, каф. АиИТ, 24.02.2004.
//—————————————————————————————————————————————————————————————————————————————


#include <iostream>

#include <windows.h>

#include "ConvOem.h"


using namespace std;


int main()
{
	// Объявление объекта буфера конверсии заданного размера (здесь 100
	//	символов, включая 0-символ). По умолчанию размер равен 256 символам.
	CConvOem szBuff(100);
	if (szBuff.isInvalid()) return -1; 	// Ошибка создания буфера.

	// Пример изменения размера буфера на 200 символов.
	szBuff.resize(200);
	if (szBuff.isInvalid()) return -1; 	// Ошибка создания буфера.

	// Пример вывода строки и символа на консоль.
	cout << szBuff.toOem("Вывожу на консоль символ 'ю': ")
		<< szBuff.toOem('ю') << szBuff.toOem('.') << endl;

	// Пример ввода символа с консоли и проверки введенного символа.
	CHAR ch;
	cout << szBuff.toOem("Ведите символ 'я': "); cin >> ch;
	CHAR ch1 = szBuff.fromOem(ch);
	if (ch1 == 'я')
		cout << szBuff.toOem("Совпадение!!! Вы ввели символ 'я'.") << endl;

	// Пример ввода строки с консоли и проверки введенной строки.
	CHAR buff[50];
	cout << szBuff.toOem("Ведите строку \"Эхо\": "); cin >> buff;
	const CHAR *pcstr = szBuff.fromOem(buff);
	if (pcstr[0] == 'Э' && pcstr[1] == 'х' && pcstr[2] == 'о')
		cout << szBuff.toOem("Совпадение!!! Введена строка \"Эхо\".\n");
	cout << szBuff.toOem("Проверка закончена.") << endl;
	
	// Замечание:
	//	Не следует использовать конструкции, подобные следующей:
	//		cout << szBuff.toOem("Строка 1.\n")
	//			<< szBuff.toOem("Строка 2.\n")
	//			<< szBuff.toOem("Строка 3.\n");
	//	Здесь просто трижды выведется одна из этих строк, например, "Строка 1",
	//	т. к. все три вызова szBuff.toOem(...) возвращают адрес одного и
	//	того же буфера и производятся до вывода результатов на экран.
	//	То же самое происходит при использовании printf() при вызовах вида:
	//		printf("%s%s%s",
	//			szBuff.toOem("Строка 1.\n"),
	//			szBuff.toOem("Строка 2.\n"),
	//			szBuff.toOem("Строка 3.\n"));
	//	Однако, возможно использование конструкций вида:
	//		cout << szBuff.toOem('Э')
	//			<< szBuff.toOem('Ю')
	//			<< szBuff.toOem('Я') << endl;
	//	Выведет: "ЭЮЯ".

	return 0;
}
